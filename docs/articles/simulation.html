<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Intro to data simulation and visualization • WILD6900</title>
<!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script><!-- Bootstrap --><link href="https://cdnjs.cloudflare.com/ajax/libs/bootswatch/3.3.7/spacelab/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha256-U5ZEeKfGNOja007MMD3YBI0A3OSZOQbeG6z2f2Y0hu8=" crossorigin="anonymous"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" integrity="sha256-eZrrJcwDc/3uDhsdt61sL2oOBY362qM3lon1gyExkL0=" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" integrity="sha256-FiZwavyI2V6+EXO1U+xzLG3IKldpiTFf3153ea9zikQ=" crossorigin="anonymous"></script><!-- sticky kit --><script src="https://cdnjs.cloudflare.com/ajax/libs/sticky-kit/1.1.3/sticky-kit.min.js" integrity="sha256-c4Rlo1ZozqTPE2RLuvbusY3+SU1pQaJC0TjuhygMipw=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script><meta property="og:title" content="Intro to data simulation and visualization">
<meta property="og:description" content="">
<meta name="twitter:card" content="summary">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">WILD6900</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="Released version">2019.1</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../index.html">
    <span class="fa fa-home"></span>
     
  </a>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right">
<li>
  <a href="../articles/syllabus.html">
    <span class="fas fa fas fa-book"></span>
     
    Syllabus
  </a>
</li>
<li>
  <a href="../articles/schedule.html">
    <span class="fas fa fas fa-calendar"></span>
     
    Schedule
  </a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    <span class="fa fa-file-pdf-o"></span>
     
    Lectures
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../articles/Lecture0/Lecture0.html">Lecture 0: Introduction to WILD6900</a>
    </li>
    <li>
      <a href="../articles/Lecture1/Lecture1.html">Lecture 1: Introduction to statistical inference in ecology</a>
    </li>
    <li>
      <a href="../articles/Lecture2/Lecture2.html">Lecture 2: Probability refresher (or introduction)</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    <span class="fas fa fas fa-desktop"></span>
     
    Labs
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../articles/projects_and_directories.html">Projects and directories</a>
    </li>
    <li>
      <a href="../articles/rmarkdown_intro.html">Introduction to R Markdown</a>
    </li>
  </ul>
</li>
<li>
  <a href="../articles/homework.html">
    <span class="fas fa fas fa-pencil-square-o"></span>
     
    Assignments
  </a>
</li>
      </ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      
      </header><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1>Intro to data simulation and visualization</h1>
                        <h4 class="author">WILD6900</h4>
            
            <h4 class="date">2019-01-10</h4>
      
      
      <div class="hidden name"><code>simulation.Rmd</code></div>

    </div>

    
    
<hr>
<p><strong>Objectives</strong></p>
<ul>
<li><p>blah</p></li>
<li><p>blah</p></li>
</ul>
<hr>
<div id="what-is-data-simulation" class="section level2">
<h2 class="hasAnchor">
<a href="#what-is-data-simulation" class="anchor"></a>What is data simulation</h2>
<p>Data simulation is a technique for generating random data from stochastic processes with known parameters. Although not framed as “data simulation”, we have already done this several times this semester. For example,</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw"><a href="https://www.rdocumentation.org/packages/stats/topics/Normal">rnorm</a></span>(<span class="dv">100</span>, <span class="dv">3</span>, <span class="fl">0.75</span>)</code></pre></div>
<p>Is a simple data simulation to generate random variables from a normal distribution with known mean (<span class="math inline">\(\mu=3\)</span>) and variance (<span class="math inline">\(\sigma^2=0.75^2 = 0.5625\)</span>). In this exercise, we’ll learn about simulating data under more complex models that are similar to the ones you might use to analyze your data. For example, imagine a simple single-season occupancy model with the probability of occupancy <span class="math inline">\(\psi=0.75\)</span> and detection probability <span class="math inline">\(p=0.4\)</span>. In other words<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>:</p>
<p><span class="math display">\[z_i \sim Bernoulli(psi)\]</span></p>
<p><span class="math display">\[y_i \sim Bernoulli(z_i \times p)\]</span></p>
<p>We can simulate a data set from this model using a few lines of <code>R</code> code:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">nSites &lt;-<span class="st"> </span><span class="dv">100</span>  <span class="co"># Number of sites</span>
psi &lt;-<span class="st"> </span><span class="fl">0.75</span>    <span class="co"># Occupancy probability</span>
p &lt;-<span class="st"> </span><span class="fl">0.4</span>       <span class="co"># Detection probability</span>

z &lt;-<span class="st"> </span><span class="kw"><a href="https://www.rdocumentation.org/packages/stats/topics/Binomial">rbinom</a></span>(<span class="dt">n =</span> nSites, <span class="dt">size =</span> <span class="dv">1</span>, <span class="dt">prob =</span> psi)     ## Generate true state of each site;
                                                  ## note that Bernoulli = binomial with size = 1 (single coin flip)
y &lt;-<span class="st"> </span><span class="kw"><a href="https://www.rdocumentation.org/packages/stats/topics/Binomial">rbinom</a></span>(<span class="dt">n =</span> nSites, <span class="dt">size =</span> <span class="dv">1</span>, <span class="dt">prob =</span> z <span class="op">*</span><span class="st"> </span>p)   ## Generate observations</code></pre></div>
<p>With those five lines of code, we know how a fake data set that could be fed into an occupancy model to estimate <span class="math inline">\(\psi\)</span> and <span class="math inline">\(p\)</span>.</p>
</div>
<div id="why-simulate-data" class="section level2">
<h2 class="hasAnchor">
<a href="#why-simulate-data" class="anchor"></a>Why simulate data?</h2>
<p>At first, it may seem strange to generate a fake data set just so we can run it through a modeling exercise to get answers we already know. But data simulation is a powerful technique in your toolbox as an ecological modeller. There are a number of reasons data simulation is useful<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a>:</p>
<ol style="list-style-type: decimal">
<li><p><em>Thruth is known</em>: Usually when we apply a model to data, we don’t know the true parameter values that generated the data. In this case, you may be able to fit the model but you’ll never know if it got the right answer. With simulated data, you can check whether your model returns the known parameter values. This is a useful way to make sure you code is doing what you <em>think</em> it’s doing.</p></li>
<li><p><em>Sampling error</em>: As we already learned, sampling error is an inherent part of any ecological analysis. The noise that results from sampling error makes it harder to detect the true signals in our process model. With real data, you only have a single data set, which makes it hard to understand the effect of sampling error on your inference. With simulated data, you can generate hundreds or even thousands of data sets from the same process/observation models, allowing you to observe the effects of sampling error directly.</p></li>
<li><p><em>Check characteristics of estimators</em>: Related to point 1, with a complex model and just a single data set it’s difficult to determine whether the estimators you are using are well-behaved; that is, do they return estimates that are unbiased and precise. With simulated data, you can directly quantify these properties.</p></li>
<li><p><em>Power analysis</em>: By varying the effect sizes and sample sizes in your simulated data, you can easily perform power analyses. Using simulated data in this way can be very useful for designing field studies or helping to interpret inferences after data has been collected and analyzed.</p></li>
<li><p><em>Check identifiability/estimability of parameters</em>: In Bayesian models, we can always obtain posteterior distributions for every parameter in our model. However, these posteriors are not always useful. In some cases, our data may provide little-to-no information about the value of a parameter and therefore the posterior distribution for this parameter will simply be determined by the prior. This lack of <em>identifiability</em> may be caused by instrinsic properties of our model (for example, if two parameters are completely confounded such that different combinations of parameter values have the same likelihood) or because our data do not provide enough information to estimate all parameters in the model (for example, a regression model with dozens of predictors but few observations). Although there are rigorous methods for testing instrinsic identifiability, this task can be extremely difficult for complex hierarchical models. Simulated data allow you to check whether all parameters in your model can be estimated by generated replicate data sets that have the same properties (sample size, etc) as your data.</p></li>
<li><p><em>Check robustness to violations of model assumptions</em>: All models have assumptions about how the data was generated. These assumptions stem from the way we formulate the process and observation models. Of course, most assumptions will be violated to some degree in real data sets. With simulated data sets, we can generate data that we know violate the assumptions of the model in one or more ways (e.g., generated heterogeneous survival probabilities for a model that assumes constant survival). By comparing the parameters estimates from these “mis-specified” data sets, we can guage the degree to which our inferences are sensitive to violations.</p></li>
<li><p><em>Better understand your model</em>: One good way to test whether you really understand your model is to see if you can write the code to simulate data under the model. In many cases, this exercise will uncover misunderstandings or lack of understanding about what the model is actually doing. Simulating data is also a good way to make sure you understand what each parameter in your model actually represents. If you can simulate data from each part of the model, chances are you can also figure out why your model may not be working the way you think it does. In short, simulating data is a great way to develop a deeper understanding of your model.</p></li>
</ol>
</div>
<div id="simulating-count-data" class="section level1">
<h1 class="hasAnchor">
<a href="#simulating-count-data" class="anchor"></a>Simulating count data</h1>
<p>In this exercise, we will simulate and visualize data generated under very general process and state models. We will simulate the data assuming a “glm” type formulation with covariates effecting both the abundances as well as the observed counts (apropos of point 7 above, we will also use this example as a brief review of glm’s).</p>
<p>Because I’m probably too guilty of being animal focused, we will assume these counts are generated a part of a study documenting the distribution of a rare orchid. Because we’re making this up as we go, we’ll assume this rare orchid prefers high elevation sites that receive a lot of rainfall each year. Therefore, we expect abundance to increase with increasing elevation and rainfall. To estimate abundance, we conduct <span class="math inline">\(M\)</span> replicated counts at <span class="math inline">\(J\)</span> sample plots. For the process model, we will assume</p>
<p><span class="math display">\[N_i \sim Poisson(\lambda_i)\]</span></p>
<p>where <span class="math inline">\(N_i\)</span> is the true abundance at site <span class="math inline">\(i\)</span> and <span class="math inline">\(\lambda_i\)</span> is the <em>expected</em> abundance<a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a>. To model the elevational and rainfall relationships, we incoporate those predictors on the (log) expected counts (we will review why we use the log counts shortly). Therefore:</p>
<p><span class="math display">\[log(\lambda_i) = \beta_0 + \beta_1 \times elevation_i + \beta_2 \times rainfall_i\]</span></p>
<p>where <span class="math inline">\(\beta_0\)</span>, <span class="math inline">\(\beta_1\)</span>, and <span class="math inline">\(\beta_2\)</span> are regression coefficients that govern the relationshp between abundance, elevation, and rainfall.</p>
<p>Even though these are plants, they are small and cryptic so no matter how hard we search on the study plots, it is likely that we won’t find every plant. This is, the probability of detecting each plant <span class="math inline">\(p &lt; 1\)</span>. Let’s assume detection probability is lowest at high elevations because our oxygen-deprived brains are bad at searching at high elevations. We’ll further assume that it’s hard to detect the species on windy days. For the observation model, we will assume:</p>
<p><span class="math display">\[y_{i,j} \sim Binomial(N_i, p_{i,j})\]</span></p>
<p>and</p>
<p><span class="math display">\[logit(p_{i,j}) = \alpha_0 + \alpha_1 \times elevation_i + \alpha_2 \times wind_{i,j}\]</span></p>
<p>where <span class="math inline">\(y_{i,j}\)</span> is the number of individuals counted at site <span class="math inline">\(i\)</span> during count <span class="math inline">\(j\)</span>, <span class="math inline">\(p_{i,j}\)</span> is the site/occasion specific detection probability, and <span class="math inline">\(\alpha_0\)</span>, <span class="math inline">\(\alpha_1\)</span>, and <span class="math inline">\(\alpha_2\)</span> are regression coefficients that govern the relationship between detection probability, elevation, and wind. Again, we will briefly review why we model detection probability on the logit scale shortly.</p>
<div id="initial-steps-setting-the-model-parameters" class="section level2">
<h2 class="hasAnchor">
<a href="#initial-steps-setting-the-model-parameters" class="anchor"></a>Initial steps: Setting the model parameters</h2>
<p>The first step to simulating data is to set the fixed values that are needed to generate the stochastic data. This usually includes the sample size, number of visits, covariate and parameter values and any other fixed value relevant to the analysis. In this case, we’ll first set the number of sites and number of visits:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">M &lt;-<span class="st"> </span><span class="dv">175</span> <span class="co"># Number of sites</span>
J &lt;-<span class="st"> </span><span class="dv">4</span>   <span class="co"># Number of replicate counts</span></code></pre></div>
<p>Next, we need to generate the covariate values, in this case elevation, rainfall, and wind. Notice that both elevation and rainfall are <em>site-level</em> covariates; they get a single value for each site. Wind is a sampling covariate so it will get one value for each site <em>and</em> each visit. For this reason, we’ll treat elevation and rainfall as vectors of length <span class="math inline">\(M\)</span> and wind as a matrix with dimensions <span class="math inline">\(c(M,J)\)</span>. For now, we’ll assume our sites vary from sea-level to 1500m in elevation, rainfall varies from 0mm to 200mm per year, and wind can vary from 0kph to 50kph. We’ll further assume that the predictors are independent (which is probably not realistic but we will ignore correlations among predictors for now)</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">sim_df &lt;-<span class="st"> </span><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/data.frame">data.frame</a></span>(<span class="dt">elevation =</span> <span class="kw"><a href="https://www.rdocumentation.org/packages/stats/topics/Uniform">runif</a></span>(M, <span class="dt">min =</span> <span class="dv">0</span>, <span class="dt">max =</span> <span class="dv">1500</span>),
                     <span class="dt">rainfall =</span> <span class="kw"><a href="https://www.rdocumentation.org/packages/stats/topics/Uniform">runif</a></span>(M, <span class="dt">min =</span> <span class="dv">0</span>, <span class="dt">max =</span> <span class="dv">200</span>),
                     <span class="dt">wind =</span> <span class="kw"><a href="https://www.rdocumentation.org/packages/stats/topics/Uniform">runif</a></span>(M<span class="op">*</span>J, <span class="dt">min =</span> <span class="dv">0</span>, <span class="dt">max =</span> <span class="dv">50</span>))</code></pre></div>
<p>In most analyses, it is good practice to scale covariate values so they have a mean of 0 and do not extend too far above and below 0 (very large values (positive or negative) can create numerical issues when fitting models). So next we center and scale the covariates (we’ll do it manually but it could also be done using the built-in function <code><a href="https://www.rdocumentation.org/packages/base/topics/scale">scale()</a></code>):</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">sim_df &lt;-<span class="st"> </span>dplyr<span class="op">::</span><span class="kw"><a href="https://dplyr.tidyverse.org/reference/mutate.html">mutate</a></span>(sim_df, <span class="dt">elevation.c =</span> (elevation <span class="op">-</span><span class="st"> </span><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/mean">mean</a></span>(elevation))<span class="op">/</span><span class="kw"><a href="https://www.rdocumentation.org/packages/stats/topics/sd">sd</a></span>(elevation),
                                <span class="dt">rainfall.c =</span> (rainfall <span class="op">-</span><span class="st"> </span><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/mean">mean</a></span>(rainfall))<span class="op">/</span><span class="kw"><a href="https://www.rdocumentation.org/packages/stats/topics/sd">sd</a></span>(rainfall),
                                <span class="dt">wind.c =</span> (wind <span class="op">-</span><span class="st"> </span><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/mean">mean</a></span>(wind))<span class="op">/</span><span class="kw"><a href="https://www.rdocumentation.org/packages/stats/topics/sd">sd</a></span>(wind))</code></pre></div>
<p>You can check that these now have mean = 0 and sd = 1.</p>
<p>Finally, we need to set the parameter values for the regression models. This is where understanding what each parameter represents is very helpful. For example, <span class="math inline">\(\beta_0\)</span> is the expected number of orchids (on the log scale) when the other covariates have a value of 0 (because we centered elevation and rainfall, we interpret <span class="math inline">\(\beta_0\)</span> to be the expected abundance at the mean elevation and rainfall rather than at sea-level and 0mm of rain). Thinking about counts on the log scale is hard so we’ll set this value on the abundance scale and then transform to get <span class="math inline">\(\beta_0\)</span>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">mean.lambda &lt;-<span class="st"> </span><span class="dv">2</span>           <span class="co"># Mean expected number of orchids</span>
(beta0 &lt;-<span class="st"> </span><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/Log">log</a></span>(mean.lambda))  <span class="co"># Log expected number of orchids (intercept)</span>
<span class="co">#&gt; [1] 0.6931</span></code></pre></div>
<p>We can do the same thing with <span class="math inline">\(\alpha_1\)</span>, which is the (logit) expected detection probability at the mean abundance and wind:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">mean.p &lt;-<span class="st"> </span><span class="fl">0.65</span>
(alpha0 &lt;-<span class="st"> </span><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/Log">log</a></span>(mean.p<span class="op">/</span>(<span class="dv">1</span><span class="op">-</span>mean.p)))
<span class="co">#&gt; [1] 0.619</span></code></pre></div>
<p>Now we set the other regression coefficients. We have already said the <span class="math inline">\(\beta_1\)</span> is positive (abundance increases with elevation) whereas <span class="math inline">\(\beta_2\)</span>, <span class="math inline">\(\alpha_1\)</span>, and <span class="math inline">\(\alpha_2\)</span> are negative (abundance decreases with increasing rainfall; detection probability decreases with increasing elevation and wind). All that’s left is to decide specific values. I recommend playing with these values a bit to get a feel for effect sizes on the log and logit scales. Both <span class="math inline">\(\lambda\)</span> and <span class="math inline">\(p\)</span> are derived variables based on the regression models and it’s not always obvious what values of the regression coefficients will generate reasonable abundances and counts. Simulating data under different effect sizes is a good way to build intuition about what a “large” effect size is in glms.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">beta1 &lt;-<span class="st"> </span><span class="fl">0.6</span>   <span class="co"># Effect of elevation on abundance</span>
beta2 &lt;-<span class="st"> </span><span class="op">-</span><span class="dv">1</span> <span class="co"># Effect of rainfall on abundance</span>
 
alpha1 &lt;-<span class="st"> </span><span class="op">-</span><span class="fl">0.75</span> <span class="co"># Effect of elevation on detection probability</span>
alpha2 &lt;-<span class="st"> </span><span class="op">-</span><span class="dv">1</span>    <span class="co"># Effect of wind on detection probability</span></code></pre></div>
</div>
<div id="generate-expected-abundancesreview-of-generalized-linear-models" class="section level2">
<h2 class="hasAnchor">
<a href="#generate-expected-abundancesreview-of-generalized-linear-models" class="anchor"></a>Generate expected abundances/review of (generalized) linear models</h2>
<p>To generate the simulated abundances at each site, we first have to calcuate <span class="math inline">\(\lambda_i\)</span>, the <em>expected</em> abundance at each site. If this is confusing, remember that a linear model is composed to two parts:</p>
<p><span class="math display">\[response = deterministic\; part+stochastic\; part\]</span></p>
<p><img src="simulation_files/figure-html/unnamed-chunk-9-1.png" width="576" style="display: block; margin: auto;"></p>
<p>In the figure above, the line in the deterministic part of the model – the predicted value of <span class="math inline">\(y\)</span> for a given value of <span class="math inline">\(x\)</span>. It’s deterministic because for a given value of <span class="math inline">\(x\)</span>, it will always return the same predicted value of <span class="math inline">\(y\)</span>. In our abundance model, <span class="math inline">\(\lambda_i\)</span> is the deterministic part of the model – the predicted abundance of the orchid at a specific combination of elevation and rainfall.</p>
<p>We get these values by simply plugging in the observed elevation and rainfall values for each site to our linear model:</p>
<p><span class="math display">\[\begin{bmatrix}
    response_1 \\
    reponse_2 \\
    response_3 \\
    .\\
    .\\
    .\\
    response_M
\end{bmatrix} = \begin{bmatrix}
    1  &amp; elevation_1 &amp; rainfall_1\\
    1  &amp; elevation_2 &amp; rainfall_2 \\
    1  &amp; elevation_3 &amp; rainfall_3 \\
    . &amp; . &amp;.\\
    . &amp; . &amp;.\\
    . &amp; . &amp;.\\
    1  &amp; elevation_M &amp; rainfall_M
\end{bmatrix} \times
\begin{bmatrix}
    \beta0 &amp; \beta1 &amp; \beta2
\end{bmatrix}\]</span></p>
<p>If you remember matrix algebra, multiplying the covariate matrix by the coefficient matrix is the same as doing:</p>
<p><span class="math display">\[1 \times \beta0 + elevation_i \times \beta1 + rainfall_i \times \beta2\]</span></p>
<p>The matrix of predicted responses is called the <em>linear predictor</em>. Notice that when we calculate the linear predictor for our data, some of the predicted abundances are negative:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">pred_abun &lt;-<span class="st"> </span>beta0 <span class="op">+</span><span class="st"> </span>beta1 <span class="op">*</span><span class="st"> </span>sim_df<span class="op">$</span>elevation.c <span class="op">+</span><span class="st"> </span>beta2 <span class="op">*</span><span class="st"> </span>sim_df<span class="op">$</span>rainfall.c
<span class="kw"><a href="https://www.rdocumentation.org/packages/graphics/topics/hist">hist</a></span>(pred_abun)</code></pre></div>
<p><img src="simulation_files/figure-html/unnamed-chunk-10-1.png" width="576" style="display: block; margin: auto;"></p>
<p>In our model, this makes no sense – abundance can’t be negative. However, note that if we take <span class="math inline">\(e^{response}\)</span> we end up with positive values:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="https://www.rdocumentation.org/packages/graphics/topics/hist">hist</a></span>(<span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/Log">exp</a></span>(pred_abun))</code></pre></div>
<p><img src="simulation_files/figure-html/unnamed-chunk-11-1.png" width="576" style="display: block; margin: auto;"></p>
<p>This is why our linear model refers to <span class="math inline">\(log(N)\)</span> rather than <span class="math inline">\(N\)</span>. In the case, <code><a href="https://www.rdocumentation.org/packages/base/topics/Log">log()</a></code> is called the <em>link function</em> and this is what makes our model a <em>generalized linear model</em>.</p>
<p>Now that we have a refreshed our memory of the basic glm structure, let’s add the predicted abundance for each site to the data frame:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">sim_df &lt;-<span class="st"> </span>dplyr<span class="op">::</span><span class="kw"><a href="https://dplyr.tidyverse.org/reference/mutate.html">mutate</a></span>(sim_df, <span class="dt">log.lambda =</span> beta0 <span class="op">+</span><span class="st"> </span>beta1<span class="op">*</span>elevation.c <span class="op">+</span><span class="st"> </span>beta2 <span class="op">*</span><span class="st"> </span>rainfall.c, 
                                <span class="dt">lambda =</span> <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/Log">exp</a></span>(log.lambda))</code></pre></div>
</div>
<div id="plot-relationships" class="section level2">
<h2 class="hasAnchor">
<a href="#plot-relationships" class="anchor"></a>Plot relationships</h2>
<p>Whenever you simulate data, it’s very useful to plot your data early and often. As we mentioned above, it’s often difficult to know ahead of time exactly what reponse values a complex model will produce. Plots are a great way to quickly assess whether the simulation is producing values that are consistent with your domain expertise.</p>
<div id="brief-intro-to-ggplot2" class="section level3">
<h3 class="hasAnchor">
<a href="#brief-intro-to-ggplot2" class="anchor"></a>Brief intro to <code>ggplot2</code>
</h3>
<p>To be consistent with our use of the <code>tidyverse</code>, we will create plots using <code>ggplot2()</code>.</p>
<p>The power and flexibility of <code>ggplot2</code> come from it’s consistent structure. Although a bit overwhelming at first, once you get the hang of it the structure actually makes it quite easy to create highly customized publication-quality graphics. All plots created using <code>ggplot2</code> use the same underlying structure:</p>
<p><span class="math display">\[\underbrace{ggplot}_{initiate\; plot}(\underbrace{data = df}_{data\;frame},\; \underbrace{aes(x =\; , y = \;)}_{plot\; attributes}) + \underbrace{geom\_line()}_{geometry}\]</span></p>
<p>The <code>ggplot()</code> function initiates a new plot. In this function, you tell <code>ggplot2</code> what data frame you will be using for the plot and you tell it how to map attributes of the data to the visual properties of the figures. Attributes are mapped inside the <code>aes()</code> argument. Attributes usually include location (<code>x-axis</code> and <code>y-axis</code> placement), color, size, shape, line type, and many others. In general, each attribute will be mapped to one column of your data frame.</p>
<p>The <code>ggplot()</code> function simply initiates a graph but if you run just that portion of the code you will get a blank graph. We can see that by creating a new plot showing the relationship between elevation (the x-axis of the plot) and predicted abundance (the y-axis):</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(<span class="dt">data =</span> sim_df, <span class="kw">aes</span>(<span class="dt">x =</span> elevation, <span class="dt">y =</span> lambda))</code></pre></div>
<p><img src="simulation_files/figure-html/unnamed-chunk-13-1.png" width="576" style="display: block; margin: auto;"></p>
<p>You can see that <code>ggplot</code> created a figure with the correct axes and labels. But no data. That’s because we didn’t tell <code>ggplot</code> what type of <em>geometry</em> to use to represent the data. Geometry refers to the actual type geometric object(s) we want to use to display the data. Common geometries include points (e.g., scatterplot), lines (e.g., timeseries), and bars (e.g., histograms). There are many others. Once we add a geometry, we can see the data:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(<span class="dt">data =</span> sim_df, <span class="kw">aes</span>(<span class="dt">x =</span> elevation, <span class="dt">y =</span> lambda)) <span class="op">+</span><span class="st"> </span><span class="kw">geom_point</span>()</code></pre></div>
<p><img src="simulation_files/figure-html/unnamed-chunk-14-1.png" width="576" style="display: block; margin: auto;"></p>
<p>Going back to the <code>aes()</code> argument, we can use other attributes to disply additional information in our graph. For example, we could also show</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(<span class="dt">data =</span> sim_df, <span class="kw">aes</span>(<span class="dt">x =</span> elevation, <span class="dt">y =</span> lambda, <span class="dt">size =</span> rainfall)) <span class="op">+</span><span class="st"> </span><span class="kw">geom_point</span>()</code></pre></div>
<p><img src="simulation_files/figure-html/unnamed-chunk-15-1.png" width="576" style="display: block; margin: auto;"></p>
</div>
</div>
</div>
<div class="footnotes">
<hr>
<ol>
<li id="fn1"><p>Note that <span class="math inline">\(z_i\)</span> can either be 1 (site <span class="math inline">\(i\)</span> is occupied) or 0 (site <span class="math inline">\(i\)</span> is unoccupied) and <span class="math inline">\(y_i\)</span> can be 1 (species detected at site <span class="math inline">\(i\)</span>) or 0 (species not detected at site <span class="math inline">\(i\)</span>). In the second equation, adding <span class="math inline">\(z_i\)</span> ensures that if the site is unoccupied (<span class="math inline">\(z_i=0\)</span>) than <span class="math inline">\(y_i\)</span> has to be 0 also. We’ll learn more about this formulation of occupancy models later in the semester<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>Based on chapter 4 of Kery &amp; Royle <em>Applied Hierarchical Modeling in Ecology</em><a href="#fnref2">↩</a></p></li>
<li id="fn3"><p>Remember our discussion of probability distributions. The Poisson distribution generates random integer values greater than 0. Both the mean and variance of the Poisson distribution <span class="math inline">\(= \lambda\)</span>.<a href="#fnref3">↩</a></p></li>
</ol>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="sidebar">
        <div id="tocnav">
      <h2 class="hasAnchor">
<a href="#tocnav" class="anchor"></a>Contents</h2>
      <ul class="nav nav-pills nav-stacked">
<li><a href="#what-is-data-simulation">What is data simulation</a></li>
      <li><a href="#why-simulate-data">Why simulate data?</a></li>
      <li>
<a href="#simulating-count-data">Simulating count data</a><ul class="nav nav-pills nav-stacked">
<li><a href="#initial-steps-setting-the-model-parameters">Initial steps: Setting the model parameters</a></li>
      <li><a href="#generate-expected-abundancesreview-of-generalized-linear-models">Generate expected abundances/review of (generalized) linear models</a></li>
      <li><a href="#plot-relationships">Plot relationships</a></li>
      </ul>
</li>
      </ul>
</div>
      </div>

</div>


      <footer><div class="copyright">
  <p>Developed by Clark Rushing.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="https://pkgdown.r-lib.org/">pkgdown</a> 1.3.0.</p>
</div>
      </footer>
</div>

  

  </body>
</html>
