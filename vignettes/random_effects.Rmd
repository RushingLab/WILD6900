---
title: "Introduction to random effects and hierarchical models"
author: "WILD6900"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
header-includes:
  - \usepackage{amsmath}
  
vignette: >
  %\VignetteIndexEntry{poisson_glm}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(fig.align = 'center', message = FALSE,
  collapse = TRUE,
  comment = "#>"
)
library(WILD6900)
```

In this activity, we will use the process of simulating data to understand what random effects are and how they are interpreted in hierarchical models.

***
**Objectives**

* Simulate data sets with both fixed and random effect structure   

* Fit fixed and random effects models in JAGS  

***

For this lab, let's assume we're interested in modeling the the body mass (g) of lizards as a function of body length (mm). We capture lizards on $J$ study plots and measure the mass and length of each individual. 

## The model

In this example, we have a single continuous predictor variable and $J$ levels of a factor. We'll assume for now that the residual body mass of each individual is normally distributed after accounting for body length. This suggests that following model:

$$y_{ij} = \alpha_{[j]} + \beta \times x_i + \epsilon_i$$

$$\alpha_{[j]} \sim normal(\mu_{alpha}, \tau_{alpha})$$

$$\epsilon_i \sim normal(0, \tau)$$

First, set up the simulation parameters:

```{r eval = FALSE}
J <- 20               # Number of sites
N <- 200              # Number of observations
Length <- rnorm(N)    # Scaled body length

## Randomly determine each individuals study plot
plot <- sample(x = 1:J, size = N, replace = TRUE)
table(plot)
```

```{r echo = FALSE}
J <- 20               # Number of sites
N <- 200              # Number of observations
Length <- rnorm(N)    # Scaled body length

## Randomly determine each individuals study plot
plot <- sample(x = 1:J, size = N, replace = TRUE)
knitr::kable(table(plot))
```

Now, let's set the parameters in the model: 

```{r}
mu.alpha <- 23   # Overall mean body mass
sigma.alpha <- 2 # standard deviation of group-level means
tau.alpha <- 1/sigma.alpha^2

alpha <- rnorm(J, mu.alpha, sigma.alpha)

beta <- 6     # Slope of body length on mass
sigma <- 3    # Residual standard deviation
tau <- 1/sigma^2
```

To create the linear predictor, we'll use the `model.matrix()` function to create the model matrix corresponding to our model and then multiply it by our parameters:

```{r}
Xmat <- model.matrix(~as.factor(plot) + Length - 1)
Xmat[1:5,c(1,2,3,21)]
```

Now use matrix multiplicaiton to create the linear predictor:

```{r}
linear.pred <- Xmat %*% c(alpha, beta)
head(linear.pred)
```

And finally generate the observations and combine the relevant vectors within a single data frame:

```{r fig.width=6, fig.height=6, warning=FALSE}
mass <- rnorm(N, mean = linear.pred, sd = sigma)
mass_df <- data.frame(plot = as.factor(plot), length = Length, pred_length = linear.pred, mass = mass)

ggplot(mass_df, aes(x = length, y = mass, color = plot)) +
  geom_abline(intercept = alpha, slope = beta) +
  geom_point() +
  scale_color_brewer() +
  guides(color = "none")
```


## Fitting the model

Now we're ready to fit the model in JAGS. Code for this model can be accessed with:

```{r}
model.file <- system.file("jags/random_ancova.jags", package = "WILD6900")
```

Next, prepare the data, initial values, and MCMC settings. Notice the need to generate $J$ starting values of $\alpha$:

```{r eval = FALSE}
jags_data <- list(y = mass_df$mass, N = nrow(mass_df), 
                  J = J,
                  plot = plot,
                  x = mass_df$length)

jags_inits <- function(){list(mu.alpha = rnorm(1),
                              sigma.alpha = runif(1),
                              alpha = rnorm(J), # Notice we need J initial values 
                              beta = rnorm(1),
                              tau = runif(1))}

params <- c("mu.alpha", "sigma.alpha", "alpha", "beta", "tau", "sigma")

re_fit <- jagsUI::jags(data = jags_data, inits = jags_inits,
                    parameters.to.save = params, 
                    model.file = model.file,
                    n.chains = 3, n.iter = 10000, n.burnin = 2500, n.thin = 1)

print(re_fit)
```

```{r include = FALSE}
jags_data <- list(y = mass_df$mass, N = nrow(mass_df), 
                  J = J,
                  plot = plot,
                  x = mass_df$length)

jags_inits <- function(){list(mu.alpha = rnorm(1),
                              sigma.alpha = runif(1),
                              alpha = rnorm(J), # Notice we need J initial values 
                              beta = rnorm(1),
                              tau = runif(1))}

params <- c("mu.alpha", "sigma.alpha", "alpha", "beta", "tau", "sigma")

re_fit <- jagsUI::jags(data = jags_data, inits = jags_inits,
                    parameters.to.save = params, 
                    model.file = model.file,
                    n.chains = 3, n.iter = 10000, n.burnin = 2500, n.thin = 1)
```

```{r echo = FALSE}
knitr::kable(re_fit$summary[1:10,], format = 'html')
```
Just for kicks, let's fit the same data to a model that assumes fixed-effects on the $\alpha$'s:

```{r eval = FALSE}
model.file <- system.file("jags/fixed_ancova.jags", package = "WILD6900")

jags_inits <- function(){list(alpha = rnorm(J), # Notice we need J initial values 
                              beta = rnorm(1),
                              tau = runif(1))}

params <- c("alpha", "beta", "tau", "sigma")

fe_fit <- jagsUI::jags(data = jags_data, inits = jags_inits,
                    parameters.to.save = params, 
                    model.file = model.file,
                    n.chains = 3, n.iter = 10000, n.burnin = 2500, n.thin = 1)

print(fe_fit)
```

```{r include = FALSE}
model.file <- system.file("jags/fixed_ancova.jags", package = "WILD6900")

jags_inits <- function(){list(alpha = rnorm(J), # Notice we need J initial values 
                              beta = rnorm(1),
                              tau = runif(1))}

params <- c("alpha", "beta", "tau", "sigma")

fe_fit <- jagsUI::jags(data = jags_data, inits = jags_inits,
                    parameters.to.save = params, 
                    model.file = model.file,
                    n.chains = 3, n.iter = 10000, n.burnin = 2500, n.thin = 1)

print(fe_fit)
```

```{r echo = FALSE}
knitr::kable(fe_fit$summary[1:10,], format = 'html')
```

Finally, combine results from the two models to visualize differences in the $\alpha$ estimates:

```{r fig.width=6, fig.height=6, warning=FALSE}

compare_mods <- data.frame(alpha_mean = c(re_fit$mean$alpha, fe_fit$mean$alpha),
                           CI_2.5 = c(re_fit$q2.5$alpha, fe_fit$q2.5$alpha),
                           CI_97.5 = c(re_fit$q97.5$alpha, fe_fit$q97.5$alpha), 
                           n = c(table(plot) - 0.15, table(plot) + 0.15),
                           model = rep(c("Random", "Fixed"), each = J))

ggplot(compare_mods, aes(x = alpha_mean, color = model, y = n)) + 
  geom_vline(xintercept = mu.alpha, color = "grey50", linetype = "longdash") +
  geom_vline(xintercept = re_fit$mean$mu.alpha, color = "#CD0200", alpha = 0.75) +
  geom_errorbarh(aes(xmin = CI_2.5, xmax = CI_97.5), height = 0) +
  geom_point(size = 4, color = "white") +
  geom_point() +
  scale_color_manual(values = c("#446E9B", "#D47500", "black")) +
  scale_x_continuous(expression(alpha)) +
  scale_y_continuous("Sample size")
```

# Quantifying changes in Coal tit (*Periparus ater*) abundance

In the remainder of this lab, you will use data from the Swiss Breeding Bird Survey to model changes in the abundance of Swiss Coal tits from 1999-2007. 

```{r out.width = 7, fig.cap="Photo by Andreas Eichler via WikiCommons]"}
knitr::include_graphics("https://upload.wikimedia.org/wikipedia/commons/b/b6/2017.01.27.-18-Paradiski-La_Plagne-Champagny-en-Vanoise--Tannenmeise.jpg")
```

A data frame containing the counts and some additional information about each site (elevation and percent forest cover) and count (observer ID and whether it was an observers first time doing a BBS survey) is included in the `WILD6900` package [^1]:

```{r eval = FALSE}
data("tits")
head(tits)
```

```{r echo = FALSE}
data("tits")
knitr::kable(head(tits), format = 'html')
```

[^1]: Data and code from KÃ©ry & Schaub 2015. *Bayesian Population Analysis using WinBugs*

### An aside on tidy data

This data frame stores data in a relatively efficient format. Because there is only a single row per site, all of the counts and predictor variables for all years are stored in a single row. This makes for a compact data frame and is generally referred to as the "wide" format. 

However, let's say we wanted to use the `glm()` function to fit a model to this counts, e.g., `lm(y ~ year)`. Or if we wanted to plot the site-specific counts across time, e.g., `ggplot(tits, aes(x = year, y = y, group = site))`. These tasks wouldn't be directly possible from this data frame. 

The issue with the wide format is that, although efficient, it's not very convienient for modeling and visualization tasks (which is what we spend most of our time doing). In more trendy terminology, wide data is not **tidy**. What does it mean for data to be tidy? [Essentially](http://vita.had.co.nz/papers/tidy-data.html), "each variable is a column, each observation is a row." In the `tits` data frame, we have seven main variables: site, year, elevation, forest, count, observer ID, and "first". Each observation is the count of coal tits at a single route in a single year. As formatted, we have several variable (`year`, `y`, `obs`, `first`) spread across multiple columns and multiple observations per row. Making this data frame tidy makes it easier to model and visualize the data. These tasks are easier because most `R` functions take vectors as input. In a tidy data frame, each column is vector corresponding to the values of a single variable. 

Before we start modeling the counts, let's tidy the `tits` data frame. We can do this with a single functions from the `tidyr` package:

```{r eval = FALSE}
tidy_counts <- tidyr::gather(tits, key = "aou", value = "count", -Year, -routeID)

head(tidy_counts)
```

```{r echo = FALSE}
tidy_counts <- tidyr::gather(ut_counts, key = "aou", value = "count", -Year, -routeID)

knitr::kable(head(tidy_counts))
```

Gather turns a "wide" data frame into a "long" data frame (awesome animations courtesy of [Garrick Aden-Buie](https://github.com/gadenbuie/tidyexplain)).

```{r echo = FALSE}
knitr::include_graphics('images/tidyr-spread-gather.gif')
```